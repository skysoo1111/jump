동기화는 내장 잠금 또는 모니터 잠금이라고하는 내부 엔터티를 기반으로합니다. (API 사양은 종종이 엔티티를 단순히 "모니터"라고합니다.) 내장 잠금은 동기화의 두 측면에서 중요한 역할을합니다. 즉 객체 상태에 대한 독점 액세스를 강화하고 가시성에 필수적인 관계를 설정합니다.

모든 객체에는 관련된 고유 잠금이 있습니다. 일반적으로 객체 필드에 독점적이고 일관된 액세스가 필요한 스레드는 객체에 액세스하기 전에 객체의 본질적 잠금을 획득 한 다음 완료되면 본질적 잠금을 해제해야합니다. 스레드는 잠금을 획득하고 잠금을 해제 한 시간 사이에 고유 잠금을 소유한다고합니다. 스레드가 내장 잠금을 소유하는 한 다른 스레드는 동일한 잠금을 얻을 수 없습니다. 다른 스레드는 잠금을 획득하려고 시도 할 때 차단됩니다.

스레드가 고유 잠금을 해제하면 해당 조치와 동일한 잠금의 후속 획득간에 발생 전 관계가 설정됩니다.

 스레드가 동기화 된 메소드를 호출하면 해당 메소드의 오브젝트에 대한 본질적인 잠금을 자동으로 획득하고 메소드가 리턴 할 때 해제합니다. 포착되지 않은 예외로 인해 리턴이 발생한 경우에도 잠금 해제가 발생합니다. 정적 메소드가 오브젝트가 아닌 클래스와 연관되어 있기 때문에 정적 동기화 메소드가 호출 될 때 어떤 일이 발생하는지 궁금 할 것입니다. 이 경우 스레드는 클래스와 연관된 Class 객체에 대한 고유 잠금을 획득합니다. 따라서 클래스의 정적 필드에 대한 액세스는 클래스의 모든 인스턴스에 대한 잠금과 다른 잠금에 의해 제어됩니다.
 => 예외로 인해 스레드 락은 언제든 풀릴 수 있다.
 => 정적 메소드에 동기화가 호출된다면 해당 클래스 객체(클래스의 모든 객체)에 대한 락을 획득한다. 정적 메소드는 객체가 아닌 클래스와 연관되어 있기 때문이다.

* Synchronized Statements
 동기화 된 코드를 작성하는 다른 방법은 동기화 된 명령문을 사용하는 것입니다. 동기화 된 메소드와 달리, 동기화 된 명령문은 고유 잠금을 제공하는 오브젝트를 지정해야합니다.
	synchronized(this)

이 예제에서 addName 메소드는 lastName 및 nameCount에 대한 변경 사항을 동기화해야하지만 다른 오브젝트의 메소드 호출 동기화를 피해야합니다. 동기화 된 코드에서 다른 개체의 메서드를 호출하면 Liveness 섹션에 설명 된 문제가 발생할 수 있습니다. 동기화 된 명령문이 없으면 nameList.add를 호출하기위한 목적으로 만 동기화되지 않은 별도의 메서드가 있어야합니다.

동기화 된 명령문은 또한 세분화 된 동기화로 동시성을 개선하는 데 유용합니다. 예를 들어, MsLunch 클래스에 결코 사용되지 않는 두 개의 인스턴스 필드 c1 및 c2가 있다고 가정하십시오. 이러한 필드의 모든 업데이트는 동기화되어야하지만 c1 업데이트가 c2 업데이트에 인터리브되는 것을 막을 이유가 없습니다. 그렇게하면 불필요한 차단을 만들어 동시성을 줄일 수 있습니다. 동기화 된 메소드를 사용하거나 이와 관련된 잠금을 사용하는 대신 잠금을 제공하기 위해 두 개의 객체를 만듭니다.
=> 세분화된 동기화에 유용함 ( 절대 연관되지 않는 두개의 필드가 존재할 때, 메소드 전체에 동기화를 걸어버리면 동시성에 문제가 발생한다.) 이 때, 유용함


* Reentrant Synchronization
스레드는 다른 스레드가 소유 한 잠금을 획득 할 수 없습니다. 그러나 스레드는 이미 소유 한 잠금을 획득 할 수 있습니다. 스레드가 동일한 잠금을 두 번 이상 획득하도록 허용하면 재진입 동기화가 가능합니다. 동기화 된 코드가 직접 또는 간접적으로 동기화 된 코드를 포함하는 메소드를 호출하고 두 코드 세트가 동일한 잠금을 사용하는 상황을 설명합니다. 재진입 동기화가 없으면 동기화 된 코드는 스레드로 인해 자체적으로 차단되지 않도록 여러 가지 추가 예방 조치를 취해야합니다.

* Atomic Access
프로그래밍에서 원자 동작은 한 번에 효과적으로 발생합니다. 원자 행동은 중간에 멈출 수 없다 : 그것은 완전히 일어나거나 전혀 일어나지 않는다. 조치가 완료 될 때까지 원자 조치의 부작용은 표시되지 않습니다. 우리는 이미 c ++와 같은 증분 표현식이 원자 적 행동을 설명하지 않는 것을 보았습니다. 아주 간단한 표현조차도 다른 행동으로 분해 될 수있는 복잡한 행동을 정의 할 수 있습니다. 그러나 원 자형으로 지정할 수있는 조치가 있습니다. 읽기 및 쓰기는 참조 변수 및 대부분의 기본 변수 (long 및 double을 제외한 모든 유형)에 대해 원자 적입니다. 읽기 및 쓰기는 휘발성으로 선언 된 모든 변수 (긴 변수 및 이중 변수 포함)에 대해 원자 적입니다. 원자 동작은 인터리브 될 수 없으므로 스레드 간섭에 대한 두려움없이 사용할 수 있습니다. 그러나 메모리 일관성 오류가 여전히 가능하기 때문에 원 자성 작업을 동기화 할 필요가 없습니다. 휘발성 변수를 사용하면 휘발성 변수에 대한 쓰기는 동일한 변수의 후속 읽기와의 사전 관계를 설정하기 때문에 메모리 일관성 오류의 위험이 있습니다. 이는 휘발성 변수에 대한 변경 사항이 항상 다른 스레드에 표시됨을 의미합니다. 또한 스레드가 휘발성 변수를 읽을 때 휘발성에 대한 최신 변경 사항뿐만 아니라 변경을 초래 한 코드의 부작용도 볼 수 있습니다. 간단한 원자 변수 액세스를 사용하는 것은 동기화 된 코드를 통해 이러한 변수에 액세스하는 것보다 효율적이지만 메모리 일관성 오류를 피하려면 프로그래머의주의가 필요합니다. 추가 노력이 가치가 있는지 여부는 응용 프로그램의 크기와 복잡성에 따라 다릅니다. java.util.concurrent 패키지의 일부 클래스는 동기화에 의존하지 않는 원자 적 메소드를 제공합니다. 높은 수준의 동시성 개체 섹션에서 이에 대해 논의 할 것입니다.

