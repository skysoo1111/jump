스레드를 경량 프로세스라고도합니다. 프로세스와 스레드는 모두 실행 환경을 제공하지만 새 스레드를 만들려면 새 프로세스를 만드는 것보다 적은 리소스가 필요합니다. 

Thread 객체를 사용하여 동시 응용 프로그램을 만드는 두 가지 기본 전략이 있습니다. 
스레드 생성 및 관리를 직접 제어하려면 응용 프로그램이 비동기 작업을 시작해야 할 때마다 스레드를 인스턴스화하면됩니다. 
나머지 응용 프로그램에서 스레드 관리를 추상화하려면 응용 프로그램의 작업을 실행 프로그램에 전달하십시오. 

이 단원에서는 Thread 객체의 사용법에 대해 설명합니다.

1. Thread Objects
	1. Runnable 객체를 사용하는 첫 번째 관용구가 더 일반적입니다. Runnable 객체는 Thread 이외의 클래스를 서브 클래스화할 수 있기 때문입니다. 
	
	2. Sleep : 실행 일시 중지 with Sleep
		휴면 기간은 인터럽트에 의해 종료 될 수 있습니다. 
		
	3. Interrupts : 스레드가 인터럽트에 응답하는 방식을 정확하게 결정하는 것은 프로그래머에게 달려 있지만 스레드가 종료되는 것은 매우 일반적입니다.
		if (Thread.interrupted())
                return;
	
	4. join : join 메소드를 사용하면 한 스레드가 다른 스레드의 완료를 기다릴 수 있습니다
		sleep과 마찬가지로 os에 따라 달라질 수 있다. 기본적으로 다른 스르데를 기다리지만 항상 그렇다고 보장할 수 없다.
		
	
2. Synchronization
	스레드는 주로 필드에 대한 액세스를 공유하여 통신하며 개체 참조 필드가 참조합니다. 
	이 통신 방식은 매우 효율적이지만 스레드 간섭 및 메모리 일관성 오류라는 두 가지 유형의 오류가 발생할 수 있습니다. 
	이러한 오류를 방지하는 데 필요한 도구는 동기화입니다.
	
	=> 그러나 동기화는 스레드 경합을 유발할 수 있다.
	: 두 개 이상의 스레드가 동일한 자원에 서로 접근하려고 할 때
	Starvation and livelock은 스레드 경합의 한 예이다.
	
	1. 스레드 간섭 : 여러 스레드가 공유 데이터에 엑세스 할 때
	
	2. 메모리 일관성 오류 : 공유 메모리의 일관성 없는 보기로 인해 발생
	메모리 일관성 오류의 원인은 복잡하며이 학습서의 범위를 벗어납니다. 다행히 프로그래머는 이러한 원인에 대한 자세한 이해가 필요하지 않습니다. 
	필요한 것은 그것들을 피하기위한 전략입니다.
	
		int counter = 0;
		
		counter++;
		
		System.out.println(counter);
		
		위 두 명령문이 동일한 스레드에서 실행된 경우 그 값이 1이라고 가정하는 것은 합리적이다.
		단, 두 명령문이 별도의 스레드에서 동작했다면 1이라고 장담할 수 없다.
		=> 이때 join()으로 그 결과 값을 보장할 수있다. 각 스레드간의 값에 관계가 생기는 것이다.
	
	3. 동기화 방법 : 위 두가지의 오류를 효과적으로 방지할 수 있는 방안
		1) 메소드 동기화
		2) 명령문 동기화	
	
		첫째, 동일한 오브젝트에서 동기화 된 메소드를 두 번 호출하여 인터리브 할 수 없습니다. 
			하나의 스레드가 객체에 대해 동기화 된 메소드를 실행하는 경우 첫 번째 스레드가 객체와 함께 완료 될 때까지 동일한 객체 블록에 대해 동기화 된 
			메소드를 호출하는 다른 모든 스레드 (일시 중단). 
		둘째, 동기화 된 메소드가 종료되면 동일한 오브젝트에 대한 동기화 된 메소드의 후속 호출과 발생 전 관계를 자동으로 설정합니다.
			이를 통해 객체 상태의 변경 사항이 모든 스레드에 표시됩니다. 생성자를 동기화 할 수 없습니다.
		
		=> 생성자와 함께 synchronized 키워드를 사용하면 구문 오류가 발생합니다. 생성자를 동기화하는 것은 의미가 없습니다. 
		객체를 생성하는 스레드 만 생성되는 동안 액세스 할 수 있어야하기 때문입니다.
		
		동기화 된 메소드는 스레드 간섭 및 메모리 일관성 오류를 방지하기위한 간단한 전략을 가능하게합니다. 
		오브젝트가 둘 이상의 스레드에 표시되면 해당 오브젝트의 변수에 대한 모든 읽기 또는 쓰기는 동기화 된 메소드를 통해 수행됩니다. 
		(중요한 예외 : 객체가 생성 된 후 수정할 수없는 최종 필드는 일단 객체가 생성되면 동기화되지 않은 메소드를 통해 안전하게 읽을 수 있습니다)
		이 전략은 효과적이지만, liveness에 문제가 생길 수 있습니다. 이 단원의 뒷부분을 참조하십시오.
		
	4. 암시적 잠금 및 동기화 : 암시적 잠금을 기반으로 하는 동기화 방안
	
	
	
	5. 원자 접근 : 다른 스레드가 방해 할 수 없는 작업의 일반적인 개념
	

* Liveness
때에 맞춰 실행하는 동시 응용 프로그램 기능을 라이브 니스라고합니다. 
이 섹션에서는 가장 일반적인 종류의 생존 문제인 교착 상태에 대해 설명하고 굶주림과 라이브 록이라는 두 가지 다른 생존 문제를 간략하게 설명합니다.

	1. Deadlock
	: 교착 상태 직면
	
	2. Starvation & Livelock
		1) Starvation : 스레드가 공유 리소스에 정기적으로 액세스 할 수없고 진행할 수없는 상황을 설명합니다. "욕심 많은"스레드에 의해 공유 리소스를 장기간 사용할 
						수없는 경우에 발생합니다.
						예를 들어, 객체가 동기화하는 데 시간이 오래 걸리는 동기화 된 메서드를 제공한다고 가정합니다. 하나의 스레드가이 메소드를 자주 호출하면 동일한
						오브젝트에 대한 동기화 된 액세스가 자주 필요한 다른 스레드도 종종 차단됩니다.
		
		2) Livelock : 스레드는 종종 다른 스레드의 동작에 응답하여 작동합니다. 다른 스레드의 동작이 다른 스레드의 동작에 대한 응답 인 경우 라이브 록이 발생할 수 있습니다. 
						교착 상태와 마찬가지로 라이브 록 스레드는 추가 진행을 할 수 없습니다. 그러나 스레드가 차단되지는 않습니다. 
						작업을 재개하기 위해 서로 응답하기에 너무 바쁩니다. 
						이것은 복도에서 서로를지나 가려고하는 두 사람과 비교할 만하다 : Alphonse는 왼쪽으로 이동하여 Gaston을 
						통과시키고 Gaston은 오른쪽으로 이동하여 Alphonse를 통과시킨다. 그들이 여전히 서로를 차단하고 있음을 알면서, 
						Alphone은 오른쪽으로 움직이고 Gaston은 왼쪽으로 움직입니다. 그들은 여전히 ​​서로를 차단하고 있습니다. 그래서 ...


* Guarded Blocks
스레드는 종종 작업을 조정해야합니다. 가장 일반적인 조정 관용구는 Guarded Blocks입니다. 이러한 블록은 블록이 진행되기 전에 참이어야하는 조건을 폴링하여 시작합니다. 
이를 올바르게 수행하기 위해 수행해야 할 여러 단계가 있습니다.
	
예를 들어, guardedJoy는 공유 변수 joy가 다른 스레드에 의해 설정 될 때까지 진행되지 않아야하는 메소드라고 가정하십시오. 이론적으로 이러한 방법은 조건이 충족 될 때까지 단순히 루프 
할 수 있지만 대기하는 동안 계속 실행되므로 루프가 낭비됩니다.	
	
	public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don't do this!
    while(!joy) {}
    System.out.println("Joy has been achieved!");
	}
		===>
	public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we're waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println("Joy and efficiency have been achieved!");
	}
	
실행을 일시 중단하는 많은 메소드와 마찬가지로 wait는 InterruptedException을 발생시킬 수 있습니다. 이 예에서 우리는 그 예외를 무시할 수 있습니다. joy의 값에만 관심이 있습니다. 
이 메소드의 guardedJoy가 synchronized된 이유는 무엇입니까? d가 대기를 호출하는 데 사용하는 객체라고 가정합니다.
스레드가 d.wait를 호출하면 d에 대한 고유 잠금을 소유해야합니다. 그렇지 않으면 오류가 발생합니다. 동기화 된 메소드 내에서 대기를 호출하면  intrinsic lock을 얻는 간단한 방법입니다.	
	
wait()이 호출되면 스레드가 잠금을 해제하고 실행을 일시 중단합니다. 나중에 다른 스레드가 동일한 잠금을 획득하고 Object.notifyAll을 호출하여 잠금을 대기중인 모든 스레드에 중요한 
작업이 발생했음을 알려줍니다.
	
	public synchronized notifyJoy() {
		joy = true;
		notifyAll();
	}
	
* Immutable Objects
객체는 생성 된 후 상태가 변경되지 않으면 Immutable으로 간주됩니다. 불변의 객체에 대한 최대 의존도는 간단하고 안정적인 코드를 만들기위한 올바른 전략으로 널리 받아 들여지고 있습니다. 
불변 개체는 동시 응용 프로그램에서 특히 유용합니다. 상태를 변경할 수 없으므로 스레드 간섭으로 인해 손상되거나 일관성이없는 상태에서 관찰 될 수 없습니다.
	
프로그래머는 종종 객체를 업데이트하는 대신 새로운 객체를 생성하는 비용에 대해 걱정하기 때문에 불변 객체를 사용하는 것을 꺼려합니다. 객체 생성의 영향은 종종 과대 평가되며 불변 객체와 
관련된 일부 효율성으로 상쇄 될 수 있습니다. 여기에는 가비지 수집으로 인한 오버 헤드 감소 및 변경 가능한 객체의 손상을 방지하는 데 필요한 코드 제거가 포함됩니다.	
	
다음 서브 섹션은 인스턴스가 변경 가능한 클래스를 가져오고 변경 불가능한 인스턴스가있는 클래스를 파생시킵니다. 그렇게함으로써 이러한 종류의 변환에 대한 일반적인 규칙을 제공하고
불변 개체의 장점을 보여줍니다.	
	
=> 불변 객체는 concurrent 프로그램에서 유용하다. 스레드 간섭이 없기 때문에
=> 불변 객체를 사용하고 새로운 객체를 생성해야하는 비용에 대해 말이 많지만 이는 불변 객체의 효율성으로 상쇄 시킬 수 있다. 가비지 수집으로 인한 오버헤드, 객체의 손상 방지를 위한 
   과도한 코드 생성
	
* A Strategy for Defining Immutable Objects
다음 규칙은 변경 불가능한 객체를 만들기위한 간단한 전략을 정의합니다. "불변"으로 문서화 된 모든 클래스가이 규칙을 따르는 것은 아닙니다. 
그렇다고 반드시이 클래스의 제작자가 조잡했다는 의미는 아닙니다. 
클래스의 인스턴스가 생성 후 절대 변경되지 않는다고 믿을만한 충분한 이유가있을 수 있습니다. 그러나 이러한 전략은 정교한 분석이 필요하며 초보자에게는 적합하지 않습니다.
	
1. "세터"메소드를 제공하지 마십시오. 필드 또는 필드가 참조하는 객체를 수정하는 메소드입니다. 
2. 모든 필드를 final 및 private으로 설정하십시오. 
3. 서브 클래스가 메소드를 대체하도록 허용하지 마십시오. 가장 간단한 방법은 클래스를 final로 선언하는 것입니다. 보다 복잡한 접근 방식은 생성자를 private으로 만들고 
	팩토리 메소드에서 인스턴스를 생성하는 것입니다. 
4. 인스턴스 필드에 가변 객체에 대한 참조가 포함 된 경우 해당 객체를 변경할 수 없습니다. 가변 객체를 수정하는 메소드를 제공하지 마십시오. 
	- 변경 가능한 객체에 대한 참조를 공유하지 마십시오.
	- 생성자에 전달 된 변경 가능한 외부 객체에 대한 참조를 저장하지 마십시오. 필요한 경우 사본을 작성하고 사본에 대한 참조를 저장하십시오. 
	  마찬가지로, 메소드에서 원본을 반환하지 않도록 필요한 경우 내부 가변 객체의 사본을 만듭니다.
	
	
	
* High Level Concurrency Objects
이 섹션에서는 버전 5.0의 Java 플랫폼에 도입 된 고급 동시성 기능 중 일부를 살펴 봅니다. 이러한 기능의 대부분은 새로운 java.util.concurrent 패키지에서 구현됩니다. 
Java Collections Framework에는 새로운 동시 데이터 구조도 있습니다.
	
	1. Lock objects 잠금 개체는 많은 동시 응용 프로그램을 단순화하는 잠금 관용구를 지원합니다. 
	2. Executors 실행자는 스레드를 시작하고 관리하기위한 고급 API를 정의합니다. java.util.concurrent가 제공하는 실행기 구현은 대규모 애플리케이션에 적합한 스레드 풀 관리를 제공합니다. 
	3. Concurrent collections 동시 수집을 통해 대규모 데이터 수집을보다 쉽게 ​​관리 할 수 ​​있으며 동기화 필요성을 크게 줄일 수 있습니다. 
	4. Atomic variables 원자 변수에는 동기화를 최소화하고 메모리 일관성 오류를 방지하는 기능이 있습니다. 
	5. ThreadLocalRandom (JDK 7)은 여러 스레드에서 의사 난수를 효율적으로 생성합니다.
		
	
	
1. Lock objects
동기화 된 코드는 단순한 종류의 재진입 잠금에 의존합니다. 이러한 종류의 잠금은 사용하기 쉽지만 많은 제한이 있습니다. 
보다 정교한 잠금 관용구는 java.util.concurrent.locks 패키지에서 지원됩니다. 이 패키지를 자세히 조사하지는 않지만 가장 기본적인 인터페이스 인 Lock에 중점을 둘 것입니다. 
잠금 개체는 동기화 된 코드에서 사용하는 암시 적 잠금과 매우 유사하게 작동합니다. 암시 적 잠금과 마찬가지로 한 번에 하나의 스레드 만 Lock 객체를 소유 할 수 있습니다. 
잠금 개체는 관련 Condition 개체를 통해 대기 / 알림 메커니즘도 지원합니다. 암시 적 잠금에 비해 잠금 오브젝트의 가장 큰 장점은 잠금 획득 시도를 취소 할 수 있다는 것입니다. 
잠금을 즉시 사용할 수 없거나 제한 시간이 만료되기 전에 (지정된 경우) tryLock 메소드가 취소됩니다. 잠금을 획득하기 전에 다른 스레드가 인터럽트를 보내면 lockInterruptibly 메소드가 취소됩니다. 
Liveness에서 본 교착 상태 문제를 해결하기 위해 Lock 객체를 사용합시다. Alphonse와 Gaston은 친구가 절을하려고 할 때주의를 기울 이도록 훈련받습니다. 
우리는 Bow를 진행하기 전에 Friend 객체가 두 참가자 모두에 대해 잠금을 획득하도록 요구함으로써 이러한 개선을 모델링합니다. 다음은 개선 된 모델 인 Safelock의 소스 코드입니다. 
이 관용구의 다재다능 함을 보여주기 위해 Alphonse와 Gaston은 서로에게 절을 멈출 수 없도록 안전하게 절을 할 수있는 새로운 능력에 너무 익숙하다고 가정합니다.
	
	
	
	
	
	
	
	